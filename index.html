<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RATS NET FLAG EDITOR</title>
  <style>
    @font-face {
      font-family: 'OCR-A';
      src: url('https://fonts.cdnfonts.com/s/14896/OCR-A.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    body {
      margin: 0;
      background: #000000;
      color: #B0B0B0;
      font-family: 'OCR-A', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.0;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 5px;
      min-height: 100vh;
      text-align: left;
      overflow: hidden;
      animation: flicker 0.25s infinite alternate;
      background-image: linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 100% 1.2px;
    }

    @keyframes flicker {
      0% { opacity: 0.8; }
      100% { opacity: 1; }
    }

    #boot-screen, #login-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
      color: #B0B0B0;
      font-family: 'OCR-A', 'Courier New', monospace;
      font-size: 14px;
      padding: 12px;
      white-space: pre;
      display: none;
      z-index: 1000;
      border: 4px solid #404040;
      animation: phosphor 0.6s infinite alternate;
    }

    @keyframes phosphor {
      0% { color: #B0B0B0; }
      100% { color: #707070; }
    }

    #login-screen textarea {
      background: #000000;
      color: #B0B0B0;
      font-family: 'OCR-A', 'Courier New', monospace;
      font-size: 14px;
      border: 2px solid #B0B0B0;
      width: 80ch;
      max-width: 100%;
      resize: none;
      padding: 3px;
    }

    #login-screen textarea:focus {
      outline: none;
      background: #404040;
    }

    #main-content {
      display: none;
      width: 100%;
      max-width: 80ch;
    }

    #rat-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .rat {
      position: absolute;
      font-size: 14px;
      user-select: none;
      color: #B0B0B0;
    }

    h1 {
      font-size: 16px;
      font-weight: normal;
      margin: 5px 0;
      border-top: 3px solid #B0B0B0;
      border-bottom: 3px solid #B0B0B0;
      padding: 3px 0;
      width: 100%;
      text-align: center;
    }

    .panel {
      border: 3px solid #B0B0B0;
      padding: 6px;
      width: 100%;
    }

    .panel h2 {
      font-size: 14px;
      font-weight: normal;
      border-bottom: 2px dashed #B0B0B0;
      margin: 0 0 6px 0;
      text-align: center;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .section {
      display: flex;
      flex-direction: column;
    }

    .lua-section {
      width: 100%;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      border: 3px solid #B0B0B0;
      padding: 6px;
      width: 100%;
    }

    .color {
      width: 40px;
      height: 20px;
      border: 2px solid #B0B0B0;
      text-align: center;
      font-size: 14px;
      line-height: 20px;
      cursor: pointer;
    }

    .color.selected {
      background: #B0B0B0;
      color: #000000;
    }

    .selected-preview {
      margin: 6px 0;
      font-size: 14px;
    }

    .preview-box {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid #B0B0B0;
      vertical-align: middle;
    }

    .grid {
      font-size: 14px;
      line-height: 1;
      border: 3px solid #B0B0B0;
      padding: 6px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .preview-grid {
      font-size: 14px;
      line-height: 1;
      border: 3px solid #B0B0B0;
      padding: 0;
      display: flex;
      flex-direction: column;
    }

    .grid-row {
      display: flex;
      gap: 2px;
    }

    .preview-row {
      display: flex;
      gap: 0;
    }

    .cell, .preview-cell {
      width: 14px;
      height: 14px;
      text-align: center;
      font-size: 14px;
      line-height: 14px;
    }

    .output {
      background: #000000;
      border: 3px solid #B0B0B0;
      padding: 6px;
      white-space: pre;
      margin-top: 6px;
      max-width: 100%;
      overflow-x: auto;
      font-size: 14px;
    }

    button {
      background: #000000;
      color: #B0B0B0;
      font-family: 'OCR-A', 'Courier New', monospace;
      font-size: 14px;
      padding: 3px 6px;
      border: 2px solid #B0B0B0;
      cursor: pointer;
      margin: 3px;
      text-align: left;
    }

    button:hover {
      background: #B0B0B0;
      color: #000000;
    }

    button:active {
      background: #404040;
      color: #000000;
    }

    button:disabled {
      color: #404040;
      cursor: not-allowed;
    }

    .discord-note {
      font-size: 14px;
      margin-top: 6px;
    }

    #error-popup {
      position: fixed;
      top: 12px;
      left: 12px;
      background: #000000;
      color: #B0B0B0;
      padding: 6px;
      border: 3px solid #B0B0B0;
      display: none;
      font-size: 14px;
      max-width: 80ch;
    }

    #loading-spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 18px;
      height: 18px;
      border: 3px solid #B0B0B0;
      border-top: 3px solid #000000;
      border-radius: 50%;
      animation: spin 1.2s linear infinite;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 6px 0;
    }

    @media (max-width: 768px) {
      body, #boot-screen, #login-screen, .palette, .grid, .preview-grid, .output, button, h1, h2, .color, .cell, .preview-cell {
        font-size: 12px;
      }
      .color, .cell, .preview-cell {
        width: 12px;
        height: 12px;
        line-height: 12px;
      }
      .preview-box {
        width: 12px;
        height: 12px;
      }
      h1 { font-size: 14px; }
      #login-screen textarea { font-size: 12px; }
    }

    @media (max-width: 480px) {
      body, #boot-screen, #login-screen, .palette, .grid, .preview-grid, .output, button, h1, h2, .color, .cell, .preview-cell {
        font-size: 10px;
      }
      .color, .cell, .preview-cell {
        width: 10px;
        height: 10px;
        line-height: 10px;
      }
      .preview-box {
        width: 10px;
        height: 10px;
      }
      h1 { font-size: 12px; }
      #login-screen textarea { font-size: 10px; }
    }
  </style>
</head>
<body>
  <div id="boot-screen"></div>
  <div id="login-screen"></div>
  <div id="main-content">
    <div id="rat-container"></div>
    <div id="error-popup"></div>
    <div id="loading-spinner"></div>

    <h1>=== RATS NET FLAG EDITOR v0.1 ===</h1>

    <div class="selected-preview">
      COLOR: <div class="preview-box" id="selected-color"></div> <span id="selected-color-name"></span>
    </div>

    <div class="palette" id="palette"></div>
    <div class="button-group">
      <button onclick="fillEntireGrid()" title="Fill Grid (F)">[F] FILL</button>
      <button onclick="clearGrid()" title="Clear Grid (C)">[C] CLEAR</button>
      <button onclick="undo()" title="Undo (U)">[U] UNDO</button>
      <button onclick="redo()" title="Redo (R)">[R] REDO</button>
      <button onclick="toggleDragMode()" title="Toggle Drag Mode (D)">
        [D] DRAG: <span id="drag-mode-text">ON</span>
      </button>
      <button onclick="toggleRats()" title="Toggle Noise (T)">
        [T] NOISE: <span id="rats-text">HIGH</span>
      </button>
      <button onclick="saveAsPNG()" title="Save as PNG (S)">[S] SAVE PNG</button>
      <button onclick="generateLuaTable()" title="Generate Lua (G)">[G] GEN LUA</button>
      <button onclick="copyLuaTable()" title="Copy Lua (Y)">[Y] COPY LUA</button>
      <button onclick="pasteLuaTable()" title="Paste Lua (P)">[P] PASTE LUA</button>
    </div>

    <div class="panel">
      <div class="container">
        <div class="section">
          <h2>FLAG GRID</h2>
          <div class="grid" id="flag-grid"></div>
        </div>
        <div class="section">
          <h2>PREVIEW</h2>
          <div class="preview-grid" id="in-game-preview"></div>
        </div>
        <div class="lua-section">
          <h2>LUA OUTPUT</h2>
          <div class="output" id="lua-output"></div>
          <div class="discord-note" id="discord-note" style="display: none">
            SEND LUA TO @KARL_SR ON DISCORD
          </div>
        </div>
      </div>
    </div>
  </div>

  <canvas id="flag-canvas" width="360" height="300" style="display:none;"></canvas>

  <script>
    // Global variables
    const paletteColors = [
      "#000000", "#00007F", "#007F00", "#007F7F", "#7F0000", "#7F007F", "#7F3F00",
      "#7F7F7F", "#3F3F3F", "#3F3FFF", "#3FFF3F", "#3FFFFF", "#FF3F3F", "#FF3FFF",
      "#FFFF3F", "#FFFFFF"
    ];
    const colorNames = [
      "BLACK", "DARK BLUE", "DARK GREEN", "DARK CYAN", "DARK RED", "DARK PURPLE",
      "DARK ORANGE", "LIGHT GRAY", "DARK GRAY", "LIGHT BLUE", "LIGHT GREEN",
      "LIGHT CYAN", "LIGHT RED", "MAGENTA", "YELLOW", "WHITE"
    ];
    let gridData = Array.from({ length: 5 }, () => Array(12).fill(16));
    let selectedColor = 1;
    let isPainting = false;
    let history = [];
    let historyIndex = -1;
    let dragMode = true;
    let ratIntensity = 'high';
    let lastRatUpdate = 0;
    const RAT_UPDATE_INTERVAL = 500;
    let palette, selectedColorBox, selectedColorName, flagGrid, inGamePreview,
        luaOutput, discordNote, canvas, ctx, errorPopup, loadingSpinner,
        bootScreen, loginScreen, mainContent, ratContainer, rats = [], selectedColorIndex = 0;
    let clickSound;

    // Global functions
    function selectColor(i) {
      selectedColor = i + 1;
      selectedColorBox.style.background = paletteColors[i];
      selectedColorName.textContent = colorNames[i];
      selectedColorIndex = i;
      const swatches = document.querySelectorAll('.color');
      swatches.forEach(s => s.classList.remove('selected'));
      swatches[i].classList.add('selected');
    }

    function generateLuaTable() {
      const lua = gridData.map(row => `  {${row.join(',')}}`).join(',\n');
      luaOutput.textContent = `{\n${lua}\n}`;
      discordNote.style.display = 'block';
      clickSound.play();
    }

    function copyLuaTable() {
      const text = luaOutput.textContent;
      if (!text) {
        showError('NO LUA TO COPY');
        return;
      }
      navigator.clipboard.writeText(text)
        .then(() => showError('LUA COPIED', false))
        .catch(() => showError('COPY FAILED'));
      clickSound.play();
    }

    function saveAsPNG() {
      for (let r = 0; r < 5; r++) {
        for (let repeat = 0; repeat < 2; repeat++) {
          for (let c = 0; c < 12; c++) {
            const colorIndex = getColorIndex(gridData[r][c]);
            ctx.fillStyle = paletteColors[colorIndex];
            ctx.fillRect(c * 30, (r * 2 + repeat) * 30, 30, 30);
          }
        }
      }
      const link = document.createElement('a');
      link.download = 'FLAG.PNG';
      link.href = canvas.toDataURL();
      link.click();
      clickSound.play();
      showError('PNG SAVED', false);
    }

    async function pasteLuaTable() {
      loadingSpinner.style.display = 'block';
      let content;
      try {
        if (navigator.clipboard && navigator.clipboard.readText) {
          content = await navigator.clipboard.readText();
          if (!content) {
            throw new Error('CLIPBOARD EMPTY');
          }
        } else {
          throw new Error('CLIPBOARD NOT SUPPORTED');
        }
      } catch (err) {
        console.log('Clipboard access failed:', err.message);
        content = prompt("CLIPBOARD FAILED. PASTE LUA:", "");
        if (!content) {
          loadingSpinner.style.display = 'none';
          showError('NO LUA PASTED');
          return;
        }
      }

      try {
        const matches = [...content.matchAll(/(\d+)/g)].map(m => parseInt(m[1]));
        if (matches.length === 5 * 12) {
          matches.forEach((index, i) => {
            const r = Math.floor(i / 12);
            const c = i % 12;
            if (index >= 0 && index <= 16) {
              gridData[r][c] = index;
            } else {
              throw new Error('INVALID COLOR');
            }
          });
          renderGrid();
          renderInGamePreview();
          saveState();
          loadingSpinner.style.display = 'none';
          showError('LUA LOADED', false);
        } else {
          loadingSpinner.style.display = 'none';
          showError('INVALID LUA FORMAT');
        }
      } catch (err) {
        loadingSpinner.style.display = 'none';
        showError('ERROR: ' + err.message);
      }
      clickSound.play();
    }

    function toggleRats() {
      ratIntensity = ratIntensity === 'high' ? 'low' : 'high';
      document.getElementById('rats-text').textContent = ratIntensity.toUpperCase();
      initRats();
      clickSound.play();
    }

    function toggleDragMode() {
      dragMode = !dragMode;
      document.getElementById('drag-mode-text').textContent = dragMode ? 'ON' : 'OFF';
      clickSound.play();
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        gridData.forEach((row, r) => {
          row.forEach((_, c) => {
            gridData[r][c] = history[historyIndex][r][c];
          });
        });
        renderGrid();
        renderInGamePreview();
        updateUndoRedoButtons();
        clickSound.play();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        gridData.forEach((row, r) => {
          row.forEach((_, c) => {
            gridData[r][c] = history[historyIndex][r][c];
          });
        });
        renderGrid();
        renderInGamePreview();
        updateUndoRedoButtons();
        clickSound.play();
      }
    }

    function clearGrid() {
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 12; c++) {
          gridData[r][c] = 16;
        }
      }
      renderGrid();
      renderInGamePreview();
      saveState();
      clickSound.play();
    }

    function fillEntireGrid() {
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 12; c++) {
          gridData[r][c] = selectedColor;
        }
      }
      renderGrid();
      renderInGamePreview();
      saveState();
      clickSound.play();
    }

    // Helper functions
    function getColorIndex(luaIndex) {
      if (luaIndex === 0) return 15;
      return luaIndex - 1;
    }

    function pickColorFromCell(r, c) {
      const luaIndex = gridData[r][c];
      const colorIndex = getColorIndex(luaIndex);
      selectColor(colorIndex);
      showError(`COLOR: ${colorNames[colorIndex]}`, false);
    }

    function renderGrid() {
      flagGrid.innerHTML = '';
      for (let r = 0; r < 5; r++) {
        const row = document.createElement("div");
        row.className = "grid-row";
        for (let c = 0; c < 12; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          const colorIndex = getColorIndex(gridData[r][c]);
          cell.textContent = colorIndex === 15 ? '.' : '#';
          cell.style.background = paletteColors[colorIndex];
          cell.style.color = colorIndex === 15 ? '#B0B0B0' : paletteColors[colorIndex];
          cell.onmousedown = (e) => {
            e.preventDefault();
            if (e.button === 2) {
              pickColorFromCell(r, c);
              return;
            }
            isPainting = true;
            gridData[r][c] = selectedColor;
            cell.textContent = selectedColor === 16 ? '.' : '#';
            cell.style.background = paletteColors[getColorIndex(selectedColor)];
            cell.style.color = selectedColor === 16 ? '#B0B0B0' : paletteColors[getColorIndex(selectedColor)];
            saveState();
            renderInGamePreview();
            clickSound.play();
          };
          cell.ontouchstart = (e) => {
            e.preventDefault();
            isPainting = true;
            gridData[r][c] = selectedColor;
            cell.textContent = selectedColor === 16 ? '.' : '#';
            cell.style.background = paletteColors[getColorIndex(selectedColor)];
            cell.style.color = selectedColor === 16 ? '#B0B0B0' : paletteColors[getColorIndex(selectedColor)];
            saveState();
            renderInGamePreview();
            clickSound.play();
          };
          cell.onmouseover = () => {
            if (isPainting && dragMode) {
              gridData[r][c] = selectedColor;
              cell.textContent = selectedColor === 16 ? '.' : '#';
              cell.style.background = paletteColors[getColorIndex(selectedColor)];
              cell.style.color = selectedColor === 16 ? '#B0B0B0' : paletteColors[getColorIndex(selectedColor)];
              saveState();
              renderInGamePreview();
              clickSound.play();
            }
          };
          cell.ontouchmove = (e) => {
            if (isPainting && dragMode) {
              const touch = e.touches[0];
              const target = document.elementFromPoint(touch.clientX, touch.clientY);
              if (target && target.classList.contains('cell')) {
                const cells = Array.from(flagGrid.querySelectorAll('.cell'));
                const index = cells.indexOf(target);
                if (index !== -1) {
                  const tr = Math.floor(index / 12);
                  const tc = index % 12;
                  gridData[tr][tc] = selectedColor;
                  target.textContent = selectedColor === 16 ? '.' : '#';
                  target.style.background = paletteColors[getColorIndex(selectedColor)];
                  target.style.color = selectedColor === 16 ? '#B0B0B0' : paletteColors[getColorIndex(selectedColor)];
                  saveState();
                  renderInGamePreview();
                  clickSound.play();
                }
              }
            }
          };
          cell.onmouseup = () => isPainting = false;
          cell.ontouchend = () => isPainting = false;
          cell.onclick = () => {
            if (!dragMode) {
              gridData[r][c] = selectedColor;
              cell.textContent = selectedColor === 16 ? '.' : '#';
              cell.style.background = paletteColors[getColorIndex(selectedColor)];
              cell.style.color = selectedColor === 16 ? '#B0B0B0' : paletteColors[getColorIndex(selectedColor)];
              saveState();
              renderInGamePreview();
              clickSound.play();
            }
          };
          cell.oncontextmenu = (e) => {
            e.preventDefault();
            pickColorFromCell(r, c);
          };
          row.appendChild(cell);
        }
        flagGrid.appendChild(row);
      }
      document.body.onmouseup = () => isPainting = false;
      document.body.ontouchend = () => isPainting = false;
      document.body.onmouseleave = () => isPainting = false;
    }

    function renderInGamePreview() {
      inGamePreview.innerHTML = '';
      for (let r = 0; r < 5; r++) {
        for (let repeat = 0; repeat < 2; repeat++) {
          const row = document.createElement("div");
          row.className = "preview-row";
          for (let c = 0; c < 12; c++) {
            const cell = document.createElement("div");
            cell.className = "preview-cell";
            const colorIndex = getColorIndex(gridData[r][c]);
            cell.style.background = paletteColors[colorIndex];
            cell.style.color = paletteColors[colorIndex];
            cell.textContent = '#';
            row.appendChild(cell);
          }
          inGamePreview.appendChild(row);
        }
      }
    }

    function saveState() {
      const state = gridData.map(row => [...row]);
      history = history.slice(0, historyIndex + 1);
      history.push(state);
      historyIndex++;
      updateUndoRedoButtons();
    }

    function updateUndoRedoButtons() {
      const undoBtn = document.querySelector('button[onclick="undo"]');
      const redoBtn = document.querySelector('button[onclick="redo"]');
      if (undoBtn) undoBtn.disabled = historyIndex <= 0;
      if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
    }

    function showError(message, isError = true) {
      errorPopup.textContent = message;
      errorPopup.style.background = isError ? '#000000' : '#B0B0B0';
      errorPopup.style.color = isError ? '#B0B0B0' : '#000000';
      errorPopup.style.display = 'block';
      setTimeout(() => {
        errorPopup.style.display = 'none';
      }, 3000);
    }

    function initRats() {
      ratContainer.innerHTML = '';
      rats = [];
      const count = ratIntensity === 'high' ? 2 : 1;
      for (let i = 0; i < count; i++) {
        const rat = document.createElement('div');
        rat.className = 'rat';
        rat.textContent = '*';
        rat.style.color = '#B0B0B0';
        rat.style.zIndex = -1;
        rat.style.opacity = 0.3;
        rat.style.fontSize = '14px';
        ratContainer.appendChild(rat);
        rats.push({
          element: rat,
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          vx: (Math.random() - 0.5) * 0.15,
          vy: (Math.random() - 0.5) * 0.15
        });
      }
    }

    function animateRats(timestamp) {
      if (timestamp - lastRatUpdate < RAT_UPDATE_INTERVAL) {
        requestAnimationFrame(animateRats);
        return;
      }
      lastRatUpdate = timestamp;

      rats.forEach(rat => {
        rat.x += rat.vx;
        rat.y += rat.vy;
        if (rat.x < 0 || rat.x > window.innerWidth) rat.vx *= -1;
        if (rat.y < 0 || rat.y > window.innerHeight) rat.vy *= -1;
        rat.element.style.transform = `translate(${rat.x}px, ${rat.y}px)`;
      });
      requestAnimationFrame(animateRats);
    }

    // DOM-dependent initialization
    document.addEventListener('DOMContentLoaded', () => {
      palette = document.getElementById("palette");
      selectedColorBox = document.getElementById("selected-color");
      selectedColorName = document.getElementById("selected-color-name");
      flagGrid = document.getElementById("flag-grid");
      inGamePreview = document.getElementById("in-game-preview");
      luaOutput = document.getElementById("lua-output");
      discordNote = document.getElementById("discord-note");
      canvas = document.getElementById("flag-canvas");
      ctx = canvas.getContext("2d");
      errorPopup = document.getElementById("error-popup");
      loadingSpinner = document.getElementById("loading-spinner");
      bootScreen = document.getElementById("boot-screen");
      loginScreen = document.getElementById("login-screen");
      mainContent = document.getElementById("main-content");
      ratContainer = document.getElementById("rat-container");

      // Initialize audio
      try {
        clickSound = new Audio();
        clickSound.src = 'https://freesound.org/data/previews/171/171671_2435923-lq.mp3';
        clickSound.onerror = () => {
          console.warn('Audio failed to load. Disabling sound.');
          clickSound = { play: () => {} };
        };
      } catch (e) {
        console.warn('Audio initialization failed:', e.message);
        clickSound = { play: () => {} };
      }

      // Boot Sequence with Ultra-Slow Auto-Typing
      const bootMessages = [
        "RATS NET FLAG EDITOR v0.1",
        "COPYRIGHT (C) 1968 RATS NET",
        "",
        "MEMORY: 1K OK",
        "CPU: PDP-8 @ 0.05MHz",
        "TTY: ASR-28 80x24",
        "ERROR 0x4D... RECOVERING",
        "PAPER TAPE: 64 BYTES OK",
        "TTY JAM DETECTED... CLEARING",
        "",
        "LOADING [          ]",
        "",
        "*** SYSTEM READY ***",
        "INITIATING SECURITY PROTOCOL"
      ];

      // Security Questions
      const securityQuestions = [
        "DO YOU HAVE EXPERIENCE WITH FIREARMS? (Y/N)",
        "ARE YOU AFFILIATED WITH THE JOKER IN ANY WAY?",
        "WHICH IS THE BEST COMPANY: NEXACO, MONSOTA, OR ULTRACORP?",
        "HAVE YOU EVER DOUBLE-CROSSED A DISK DEAL? (Y/N)",
        "WHAT IS YOUR PREFERRED WEAPON IN A CAR CHASE?",
        "ARE YOU A KNOWN RDMER IN THE CITY?",
        "HAVE YOU EVER STOLEN A TURBO (S) FROM A RIVAL CORP?",
        "DO YOU TRUST YOUR MANAGER TO NOT BETRAY YOU? (Y/N)",
        "WHAT IS THE VALUE OF A DISK IN YOUR LAST DEAL? ($)",
        "ARE YOU FLUENT IN BRAZILIAN PORTUGUESE? (Y/N)"
      ];

      async function runBootSequence() {
        bootScreen.style.display = 'block';
        let output = '';
        for (let i = 0; i < bootMessages.length; i++) {
          if (bootMessages[i].startsWith("LOADING")) {
            let bar = '';
            for (let j = 0; j < 10; j++) {
              bar += '=';
              output = bootMessages.slice(0, i).join('\n') + `\nLOADING [${bar.padEnd(10, ' ')}]`;
              bootScreen.textContent = output + (Math.random() < 0.25 ? '\nTTY ERR 0x' + Math.floor(Math.random() * 255).toString(16).toUpperCase() : '');
              await new Promise(resolve => setTimeout(resolve, 800));
            }
          } else {
            for (let char of bootMessages[i]) {
              output += char;
              bootScreen.textContent = output + '\n' + (Math.random() < 0.2 ? String.fromCharCode(0x2500 + Math.floor(Math.random() * 16)) + String.fromCharCode(0x2500 + Math.floor(Math.random() * 16)) : '');
              await new Promise(resolve => setTimeout(resolve, Math.random() * 100 + 120));
            }
            output += '\n';
            bootScreen.textContent = output;
            await new Promise(resolve => setTimeout(resolve, 300));
            if (Math.random() < 0.1) {
              bootScreen.textContent += '\n*** TTY MISALIGN ***\n';
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }
        runLoginSequence();
      }

      async function runLoginSequence() {
        bootScreen.style.display = 'none';
        loginScreen.style.display = 'block';
        let output = '=== RATS NET SECURITY PROTOCOL ===\n';
        let currentQuestion = -1; // -1 for username, 0-9 for questions
        const inputArea = document.createElement('textarea');
        inputArea.rows = 1;
        inputArea.maxLength = 80;
        loginScreen.appendChild(inputArea); // Append once at the start
        const textContainer = document.createElement('div');
        loginScreen.insertBefore(textContainer, inputArea); // Text above textarea
        inputArea.focus();

        async function displayNextPrompt() {
          if (currentQuestion === -1) {
            output += 'ENTER USERNAME: ';
          } else {
            output += `${securityQuestions[currentQuestion]}\nRESPONSE: `;
          }
          textContainer.textContent = output;
          inputArea.value = '';
          inputArea.focus();
        }

        async function handleInput(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            output += inputArea.value + '\n';
            output += Math.random() < 0.3 ? `AUTH ERR 0x${Math.floor(Math.random() * 255).toString(16).toUpperCase()}... OVERRIDE\n` : 'VALIDATING...\n';
            textContainer.textContent = output;
            await new Promise(resolve => setTimeout(resolve, 500));
            if (Math.random() < 0.1) {
              output += '*** AUTH MISALIGN ***\n';
              textContainer.textContent = output;
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            currentQuestion++;
            if (currentQuestion < securityQuestions.length) {
              await displayNextPrompt();
            } else {
              output += '*** ACCESS GRANTED ***\nPRESS KEY TO BEGIN\n';
              textContainer.textContent = output;
              if (inputArea.parentNode === loginScreen) {
                loginScreen.removeChild(inputArea); // Remove only if still a child
              }
              document.addEventListener('keydown', startMain, { once: true });
              document.addEventListener('click', startMain, { once: true });
            }
          }
        }

        inputArea.addEventListener('keydown', handleInput);
        await displayNextPrompt();
      }

      function startMain() {
        loginScreen.style.display = 'none';
        mainContent.style.display = 'block';
        renderGrid();
        renderInGamePreview();
        selectColor(0);
        saveState();
        clickSound.play();
      }

      paletteColors.forEach((color, i) => {
        const swatch = document.createElement("div");
        swatch.className = "color";
        swatch.textContent = `[${i}]`;
        swatch.style.background = color;
        swatch.tabIndex = 0;
        swatch.onclick = () => {
          selectColor(i);
          clickSound.play();
        };
        swatch.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectColor(i);
            clickSound.play();
          }
        };
        palette.appendChild(swatch);
      });

      document.addEventListener('keydown', e => {
        const swatches = document.querySelectorAll('.color');
        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          selectedColorIndex = (selectedColorIndex + 1) % paletteColors.length;
          swatches[selectedColorIndex].focus();
          selectColor(selectedColorIndex);
          clickSound.play();
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          selectedColorIndex = (selectedColorIndex - 1 + paletteColors.length) % paletteColors.length;
          swatches[selectedColorIndex].focus();
          selectColor(selectedColorIndex);
          clickSound.play();
        } else if (e.key.toLowerCase() === 'f') {
          fillEntireGrid();
        } else if (e.key.toLowerCase() === 'c') {
          clearGrid();
        } else if (e.key.toLowerCase() === 'u') {
          undo();
        } else if (e.key.toLowerCase() === 'r') {
          redo();
        } else if (e.key.toLowerCase() === 'd') {
          toggleDragMode();
        } else if (e.key.toLowerCase() === 't') {
          toggleRats();
        } else if (e.key.toLowerCase() === 's') {
          saveAsPNG();
        } else if (e.key.toLowerCase() === 'g') {
          generateLuaTable();
        } else if (e.key.toLowerCase() === 'y') {
          copyLuaTable();
        } else if (e.key.toLowerCase() === 'p') {
          pasteLuaTable();
        }
      });

      document.addEventListener('mousemove', e => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      document.addEventListener('touchmove', e => {
        if (e.touches.length > 0) {
          mouseX = e.touches[0].clientX;
          mouseY = e.touches[0].clientY;
        }
      });

      window.addEventListener('resize', () => {
        initRats();
      });

      initRats();
      requestAnimationFrame(animateRats);
      runBootSequence();
    });

    let mouseX = 0, mouseY = 0;
  </script>
</body>
</html>
